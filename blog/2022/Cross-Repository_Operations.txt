# Cross-Repository operations

At the core of AIRport are Autonomous Interdependent Repositories.  The key idea
is that they contain all of the records necessary for work on a particular unit,
such as a UI page (or a set of UI pages) while still storing everything in a
relational database (via a virtual Repository layer).

## Record tracking

As described <a href="../2021/Follow_the_Many_to_Ones.html">previously</a>
when a record gets added to a repository it drags along with it all of the
records it points to via @ManyToOne() relationships.  However it still retains
information about the original record that it was pointing to.  This is done
for every Repository Entity with the "original" fields:

@MappedSuperclass()
export class RepositoryEntity {

    // These contain identifiers for the current repository of this
    // (possibly copied) record
    repository: Repository
    actor: Actor
    actorRecordId: number


    // These contain original identifiers for the current repository
    // of this (possibly copied) record
    originalRepository: Repository
    originalActor: Actor
    originalActorRecordId: number

}

## Basic operations

The tricky thing to remember about AIRport is that all of the operations
it performs by default do not cross repository boundaries.  This means
that all relational queries will use the
"repository"/"actor"/"actorRecordId" fields for joining records.

Also all "save" operations will only modify records in the repository
of the root records passed into the operation.

This works for the majority of the cases but sometimes you really do
need to query across repositories or make modifications across them.

## Working across Repositories

The solution to this is to introduce a @CrossRepository() decorator
to Dao methods.  All query and save operations in them will work
across repositories.

export class MyDao {

    @CrossRepository()
    async myCrossRepositoryMethod(
        myRecords
    ) {

        // This find queries across repositories
        this._find({...})

        // This save works across repositories
        this.save(myRecords)
    }
}

## How this works.

### Invocation mechanics

The @CrossRepository() decorator is kept track of with on the stack
state via AIRport's <a href="../2022/Dependency_Injection.html">
dependency injection</a>.  At the time of injection of the
Dao all methods are wrapped and cross-repository methods are marked
as such.  During invocation of these methods a new stack of currently
executed DAO calls is created.  If a method is a cross-repository
one, the database API invocation is marked as being a
cross-repository one as well.

If a non cross-repository method is invoked within a cross-repository
one it will still respect the repository boundaries for all of 
the queries executed within it.  Same mechanism works for
cross-repository methods being called from non cross-repository ones,
in an inverse way.

### Query details

Cross-repository queries are actually pretty easy.  When joining
records across repositories the original 
repository/actor/actorRecordId fields are used.  Since they are always
populated (for non-copied records they contain the same values
as regular repository/actor/actorRecordId) the query works in the
same way as non cross-repository equivalent unless there are
copied records.  Joining by original identifiers will find the
original records, not their copies within this repository.

### Peristence details.

Persistence operations are also pretty easy.  Normally AIRport will
ignore nested entities that do not belong to the same repository
as the parent record.  In cross-repository methods AIRport will
perform the save across all repositories present in the graph.
Specifically (because normal foreign keys of persisten records
always point to the current repository) this means that for
all nested records in the passed in object graph that do
not belong to the current repository:

- Record Creation: records will
be created in both the the referenced repository and in the
repository of the parent record (as copies).

- Record Updates: records will be updated in the referenced
repository and a copy of the record will be created in
the repository of the parent record (replacing the currently
pointed to record, which will be deleted, along will all
record copies it has foreign keys to).

- Record Deletes: by definition deleted records must be going
against records in the current repository.  If AIRport sees
a record that needs to be deleted and does not belong to the
current repository it will throw an error.  In the case
where the deleted record has original foreign keys pointing
to another repository, the pointed-to record in the other
repository will be deleted as well.

## Use with care

Cross-repository queries work just fine in centralized databases but
are tricky in decentralized environments.  This is because the
referenced repository may not be present on the local device.  To
get around that limitation cross-repository queries will inspect the
result set and if there are missing links will attempt to load that
data by fetching the missing repositories (and subsequently will
re-run the query before it's returned).  Same goes for
cross-repository persistence operations - referenced repositories
will be loaded (though they are most likely already on the device
since they are passed into the operation).  This can lead to poor
performance characteristics of the queries.

## Enabling server optimizations

Eventually Cross-Repository queries will give AIRport a hint in 
server environments of wether the query needs to go against a
relational database or can be peformed locally against a 
repository (which is polled into memory from faster denormalized
storage).

## Interdependence is here

Cross-Repository queries finally make AIRport repositories
Interdependent  (as described in the name of Autonomous Interdependent
Repositories)!  With the cross-repository queries other repositories are
automatically pulled to the AIRport device (as a result of a query
and not with a manual action).  And with cross-repository persistence
other repositories are also updated.
