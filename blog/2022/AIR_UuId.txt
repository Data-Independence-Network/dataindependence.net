# AIR UuId

I'm now writing applications in AIRport and have found that working with AIRport ids
is cumbersome.  The reason for that is the fact that an Id of an entity
is spread across 3 different entities:

MyEntity {
    actor: {
        // backed by a foreign key column in MyEntity
        id: 123
    },
    actorRecordId: 456,
    repository: {
        // backed by a foreign key column in MyEntity
        id: 789
    },
}

## UUIDs

Moreover the ids are local to the AIR database and can differ between AIRport 
databases. Globally the records are identified by UuIds for Repository
 and Actor (in combination with actorRecordId). To get uuIds you have to join
 to the Actor and Repository tables:

MyEntity {
    actor: {
        // Exists only in 
        uuId: '123e4567-e89b-12d3-a456-426614174000'
    },
    actorRecordId: 456,
    repository: {
        uuId: '456e4567-e12b-34d3-a123-316614174000'
    },
}

### Performance

Reason for pulling out UuIds out of records is space savings.  As it stands right
now each UuId has to be stored as a string which eats up 72 bytes.  And there
are for UuIds to store - Actor UuId, Repository UuId, Original Actor UuId
and Original Repository UuId.  This adds up to 288 bytes per record.  On top of
that you have to add space for idexes for each one of these.  With that it
becomes at least half a kilobyte per record.

Modern phones have plenty of storage space (latest IPhone models at the time
of writing of this blog post come with at least 128GB of storage).  However
AIRport can also run in browser where it runs an SqlJs instance in memory.  This
is where the difference really matters.  If web AIRport has 10 repositories
loaded with just 1000 records each the UuIds alone will take up 5MB worth of RAM.
As of 2022 IPhone 14s will come with 6GB or RAM (only). And, since there is no
way to tell how much data users will keep in web AIRports or how long living web
AIRport instances will be, every byte matters.

For this reason I'm still keeping UuIds normalized in their own tables and
require joining to these tables to retrieve them.  Of course joining more tables
in queries has a negative impact on performace as well, but Actor and Repository
are much smaller tables (especially on Mobile devices) and impact is minimal.

On the server querying these can make more of an impact.  Though, eventually
the repositories will be loaded into memory on the processing nodes, thus
reducing the impact the databases.

## Usability
But the main issue with raw AIRport UuIds is usability.  Not only do you have
to include the related entities in queries but you also have to properly query
them, which can be very error prone.  On top of that, if you want to use these
ids as part of a link you now have to manually compose them into a single string
and decompose them at query time.

## New whole "UuId"
For this reason from now on all Repository Entities now include a transient "UuId" field:

@MappedSuperclass()
export class AirEntity {

    ....

    @Transient()
    uuId: string

}

This field is implemented with a getter/setter pair.  These are defined when
the record is recieved from the framework (by either an AIRport App or anything that
invokes APIs).

All the getter does is grab the uuids and the actorRecordId and concatenate them
into one large uuId:

'456e4567-e12b-34d3-a123-316614174000-123e4567-e89b-12d3-a456-426614174000-456'

## Automatic Retrieval
To make retrieval of these transparent the Dao superclass now includes _find
and _findOne methods.  These methods take a query as an input and automatically
join in all of the required tables for every entity in the select clause.

export class Dao {

    protected _find(query) { ... }

    protected _findOne(query) { ... }

    protected _findAsIs(query) { ... }

    protected _findOneAsIs(query) { ... }

}

The class also implements _findAsIs and _findOneAsIs methods, which will not
make these joins, in case you need to retrieve just the records themselves.

## Easier Queries
To make querying "by uuId" easier Dao also includes the "findByUuId" method
which takes the composite UuId, and automatically constructs the necessary
join to query the record.

For easy querying in joins all Query entites and relations now include
an "equals" and "in" methods that allow for joining by the composite UuId
(or just joining to another entity by a Query Object or actual object
references).

export class MyDao {

    async myFind(
        compositeBUuId: string,
        compositeCUuIds: string[],
    ): Promise<MyRecord[]> {
        let m: QMyRecord,
            b: QMyBRecord,
            c: QMyCRecord
        return await this._find({
            select: {
                '*': Y,
                b: {
                    '*': Y,
                    'c': {}
                }
            },
            from: [
                m = Q.MyRecord,
                b = m.b.leftJoin(),
                c = b.c.leftJoin()
            ],
            where: and(
                // equals on the query entity object
                b.equals(compositeBUuId),
                // in on the query relation object
                b.c.in(compositeCUuIds)
            )
        })
    }
}

## Bonus
As a bonus to that another field is added to AirEntity that
pulls in the User record (normally joined via the Actor table):

MyEntity {
    actor: {
        user: {
            username: 'abc',
            email: 'abc@def.com'
        }
    },
}

@MappedSuperclass()
export class AirEntity {

    ....

    @Transient()
    createdBy: User

}

The user record is also retrieved by the Dao's _find and _findOne
methods and is automatically filled in with a getter at object
retrieval time.

## Opting out

Having access to "UuId" of the record is really only needed in the
cases where there record id is used to retrieve an entity graph.
There will always be tables that are never queried by id, yet
the default _find and _findOne methods will join the tables
needed to get id (and createdBy) for every table in the "select"
clause.  So, to mitigate concerns over application performance
developers now also have a choice to opt of out of joining to
id and user tables all together by extending one of the following
classes:

@MappedSuperclass()
export class AirEntityNoUuId {
    
    @Transient()
    createdBy: string

}

@MappedSuperclass()
export class AirEntityNoCreatedBy {
    
    @Transient()
    uuId: string

}

@MappedSuperclass()
export class AirEntityNoIdNoCreatedBy {

}

These classes do not perform automatic joins when using
Dao._find(One) methods.  Specifically:

- AirEntityNoUuId: Does not join to Repository table

- AirEntityNoCreatedBy: Does not join to User table

- AirEntityNoUuIdNoCreatedBy: Does not join to Repository,
    Actor or User tables


## Final effect
Putting in this tooling makes AIRport UUID scheme transparent. From
the user (Application developer) point of view they just work with
the 'uuId' field of every record and dont' have interface with the
underlying support table structure.
