AIRport is meant to be run on both the client and the server.

On the client everything is pretty strait forward - you get one
database where all your repositories are stored (permanenty and
temporarily).  There the local integer Id scheme works well,
it saves space and query time.  UuIds are only retrieved
when you have to look objects up in other repositories.

Technically on the server the same thing holds true.  All
of the integer ids are unique to the server and still work just
fine.  However, when one looks further into what AIRport can
do an number new schenarios become apparent where numeric Id
scheme does not work.

Techincal Problems

Problem I: Decentralized & distributed

This scheme starts to break down when you start mixing the two.
AIRport applications are meant to be run with some of the
data coming from centralized (though distributed) servers
and some of the data being decentralized.  This mix gives you
the best combination of utility and privacy.  But this could
lead to id conflicts in the UIs if both distributed and
decentralized data needs to be displayed on the same screen.

Problem II: Back-end distributed

On the server side, the main goal of AIRport is to allow
application servers to load data from multiple complety
independent data sources.  The idea is for every jurisdiction
to maintain it's own data.  This CAN (and probably should be)
accomplished by having geographically distributed databases
like <a href="https://www.cockroachlabs.com/">CockroachDB</a>.  Still, AIRport should support getting
data from data sources that are come from complete different
databases (though with the same schemas).  This is particulary
useful when a private server is processing data across
multiple governmental agencies or when it's processing
data of separate (not associated with each other)
corporations.

Problem III: Performance documented

Finally there is the problem of performance.  The the
purposes of serving read queries document databases are
about an order of magnitude faster (at least in AIRport's)
case.  AIRport is particularly well suited for retrieving
entire Repositories from wide-column databases the
repository record schema is extremly simple - just
transaction log entries.  This the eventualy goal
of AIRport on the server side is to perform all virtually all
read and repository-scoped write operations in memory of
the application server and just load the data from a wide
column storage engine, like <a href="https://www.scylladb.com/">ScyllaDB</a>.
This entire repositories are loaded into in-memory 
database (SqLite) on the application servers and all of the
repository-local operations are done directly in
memory (while cross-repository queries go to the distributed
relational database or incrementally load repositories
into memory via the "original" foreign key constraits).
Performance can be further enhanced by keeping the
frequently access repositories in in-memory in SqLite
on the application servers and querying the wide column
database where repository is archived for new transaction
log entries.

The numeric ids for repositories and actors are unique only
to the SqLite database that is running on the application
server.  Thus they cannot be relied upon in update
transactions when update operation goes to another application
server (or is just re-loaded in the same application server).

The solution

The most strait forward solution to this problem is to store
all primary keys as UuIds, in the following format:

`${repository.uuId}-${actor.uuId}-${actorRecordId}`

This certainly fixes the problem but costs more in performance
particuarily in the amount of memory required to store the
data and it's indexes (and reduces the number of records
the processor can store in it's cache).

Another solution is to keep numeric ids unique to the repository
and pass around the repository UuId for all operations.  However
this doesn't work since actors of a repository can be loaded in
different order on different databases do